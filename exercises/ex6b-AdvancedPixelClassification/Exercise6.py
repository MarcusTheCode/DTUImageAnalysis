import numpy as np
import matplotlib.pyplot as plt
import scipy.io as sio
from skimage.morphology import opening, closing
from skimage.morphology import disk

in_dir = 'data/'
in_file = 'ex6_ImagData2Load.mat'
data = sio.loadmat(in_dir + in_file)
ImgT1 = data['ImgT1']
ImgT2 = data['ImgT2']
ROI_GM = data['ROI_GM'].astype(bool)
ROI_WM = data['ROI_WM'].astype(bool)

def my_show_1D_histogram(img, mask, img_name, axs):
    axs[0].imshow(img, cmap = 'gray')
    axs[0].set_title(img_name)
    axs[0].set_axis_off()

    intensities = img[mask]
    axs[1].hist(intensities, bins = 100)
    axs[1].set_title(f'1D Histogram {img_name}')
    axs[1].set_xlabel('Intensities')
    axs[1].set_ylabel('Frequency')

    return intensities

def overlay_segmentation(I, M):
    I = I/I.max()
    I_aux, I_red = I.copy(), I.copy()
    I_aux[M] = 0
    I_red[M] = 1
    tmp = np.stack((I_red, I_aux, I_aux), axis = -1)
    return tmp

def LDA(X, y):
    """
    Linear Discriminant Analysis.

    A classifier with a linear decision boundary, generated by fitting class conditional densities to the data and using Bayesâ€™ rule.
    Assumes equal priors among classes

    Parameters
    ----------
    X : array-like of shape (n_samples, n_features)
        Training data
    y : array-like of shape (n_samples,)
        Target values.

    Returns
    -------
    W : array-like of shape (n_classes, n_features+1)
        Weights for making the projection. First column is the constants.

    Last modified: 11/11/22, mcbo@dtu.dk
    """
    
    # Determine size of input data
    n, m = X.shape
    # Discover and count unique class labels
    class_label = np.unique(y)
    k = len(class_label)

    # Initialize
    n_group     = np.zeros((k,1))     # Group counts
    group_mean  = np.zeros((k,m))     # Group sample means
    pooled_cov  = np.zeros((m,m))     # Pooled covariance
    W          = np.zeros((k,m+1))    # Model coefficients

    for i in range(k):
        # Establish location and size of each class
        group      = np.squeeze(y == class_label[i])
        n_group[i]  = np.sum(group.astype(np.double))
        
        # Calculate group mean vectors
        group_mean[i,:] = np.mean(X[group,:], axis = 0)
        
        # Accumulate pooled covariance information
        pooled_cov = pooled_cov + ((n_group[i] - 1) / (n - k) ) * np.cov(X[group,:], rowvar = False)
    
    # Assign prior probabilities
    prior_prob = n_group / n

    # Loop over classes to calculate linear discriminant coefficients
    for i in range(k):
        # Intermediate calculation for efficiency
        temp = group_mean[i,:][np.newaxis] @ np.linalg.inv(pooled_cov)
        
        # Constant
        W[i,0] = -0.5 * temp @ group_mean[i,:].T + np.log(prior_prob[i])
        
        # Linear
        W[i,1:] = temp

    return W

def exercise1():

    mask_init = ImgT1 > 10
    mask = opening(mask_init, disk(2))
    mask = closing(mask, disk(3))

    fig, axs = plt.subplots(nrows = 1, ncols = 3, figsize = (10, 10))
    axs[0].imshow(ImgT1, cmap = 'gray')
    axs[1].imshow(mask_init, cmap = 'gray', interpolation = 'none')
    axs[2].imshow(mask, cmap = 'gray', interpolation = 'none')
    plt.show()

    fig, axs = plt.subplots(nrows = 2, ncols = 3, figsize = (15, 8))
    T1_intensities = my_show_1D_histogram(ImgT1, mask, 'T1w image', axs[0, 0:2])
    T2_intensities = my_show_1D_histogram(ImgT2, mask, 'T2w image', axs[1, 0:2])
    axs[0,2].hist2d(T1_intensities, T2_intensities, bins = 100)
    axs[0,2].set_xlabel('T1w intensities')
    axs[0,2].set_ylabel('T2w intensities')
    axs[0,2].set_title('2D histogram')

    axs[1,2].scatter(T1_intensities, T2_intensities)
    axs[1,2].set_xlabel('T1w intensities')
    axs[1,2].set_ylabel('T2w intensities')
    axs[1,2].set_title('Scatter plot')
    plt.tight_layout()
    plt.show()
    return mask

def exercise2():
    fig, axs = plt.subplots(nrows = 1, ncols = 1, figsize = (5, 5))
    axs.imshow(ImgT1, cmap = 'gray')
    axs.imshow(ROI_GM, cmap = 'Reds', alpha = 0.5, interpolation = 'none')
    axs.imshow(ROI_WM, cmap = 'Greens', alpha = 0.5, interpolation = 'none')
    plt.show()

def exercise3():
    # This is not necessary with the coding style followed in this solution.
    qC1 = np.argwhere(ROI_WM) # Shape (399, 2) 
    qC2 = np.argwhere(ROI_GM) # (280, 2)

    trainWM_T1 = ImgT1[ROI_WM] # trainWM_T1 = ImgT1[qC1[:,0], qC1[:,1]]
    trainGM_T1 = ImgT1[ROI_GM] # trainGM_T1 = ImgT1[qC2[:,0], qC2[:,1]]

    trainWM_T2 = ImgT2[ROI_WM] # trainWM_T2 = ImgT2[qC1[:,0], qC1[:,1]]
    trainGM_T2 = ImgT2[ROI_GM] # trainGM_T2 = ImgT2[qC2[:,0], qC2[:,1]]

    fig, axs = plt.subplots(1, 2, figsize = (12, 4), sharex = False, sharey = True)
    axs[0].hist(trainWM_T1, bins=20, color = 'navy', label = 'WM', alpha = 0.8)
    axs[0].hist(trainGM_T1, bins=20, color = 'orange', label = 'GM', alpha = 0.8)
    axs[0].set_ylabel('Frequency')
    axs[0].set_xlabel('Intensities')
    axs[0].set_title('T1w')

    axs[1].hist(trainWM_T2, bins=20, color = 'navy', label = 'WM', alpha = 0.8)
    axs[1].hist(trainGM_T2, bins=20, color = 'orange', label = 'GM', alpha = 0.8)
    axs[1].set_xlabel('Intensities')
    axs[1].set_title('T2w')
    plt.legend()
    plt.show()

def exercise4():
    # Feature matrix, X -> Shape: (n_samples, n_features)
    X1 = np.c_[ImgT1[ROI_WM], ImgT2[ROI_WM]] 
    X2 = np.c_[ImgT1[ROI_GM], ImgT2[ROI_GM]]
    X = np.r_[X1, X2]

    # Label vector, T -> Shape: (n_samples)
    n_pixels = X.shape[0]
    n_wm_pixels = X1.shape[0]
    T = np.zeros((n_pixels, 1))
    T[n_wm_pixels:] = 1
    return X, T, X1, X2

def exercise5(X1, X2):
    fig, ax = plt.subplots(1,1)
    ax.scatter(X1[:,0], X1[:,1], c = 'g', label = 'WM')
    ax.scatter(X2[:,0], X2[:,1], c = 'k', label = 'GM')
    ax.set_xlabel('T1w intensities')
    ax.set_ylabel('T2w intensities')
    plt.legend()
    plt.show()

def exercise6(X, T):
    return LDA(X, T)

def exercise7(mask, W):
    Xall= np.c_[ImgT1[mask].flatten(), ImgT2[mask].flatten()]
    Y= np.c_[np.ones((len(Xall), 1)), Xall] @ W.T
    return Xall, Y

def exercise8(Y):
    return np.clip(np.exp(Y) / np.sum(np.exp(Y),1)[:,np.newaxis], 0, 1)

def exercise9(PosteriorProb, mask):
    posteriorC1 = np.zeros(ImgT1.shape)
    posteriorC2 = np.zeros(ImgT1.shape)

    posteriorC1[mask] = PosteriorProb[:,0]
    posteriorC2[mask] = PosteriorProb[:,1]
    mask_WM = posteriorC1 >= 0.5
    mask_GM = posteriorC2 > 0.5

    fig, axs = plt.subplots(nrows = 1, ncols = 3, figsize = (10, 5))
    rgb = np.stack((posteriorC1, posteriorC2, np.zeros_like(posteriorC1)), axis = -1).astype(np.double)
    axs[0].imshow(rgb)
    axs[0].set_title('Posteriors (R-WM, G-GM)')
    axs[1].imshow(mask_WM, cmap = 'gray', interpolation = 'none')
    axs[1].set_title('WM Mask')
    axs[2].imshow(mask_GM, cmap='gray', interpolation = 'none')
    axs[2].set_title('GM Mask')
    plt.show()

    return mask_WM, mask_GM

def exercie10(PosteriorProb, Xall, X1, X2):
    Xall_WM = Xall[PosteriorProb[:,0] > 0.5, :]
    Xall_GM = Xall[PosteriorProb[:,1] > 0.5, :]

    fig, ax = plt.subplots(1,1, figsize = (10,5))
    ax.scatter(Xall_GM[:,0], Xall_GM[:,1], c = 'gray', label = 'GM')
    ax.scatter(Xall_WM[:,0], Xall_WM[:,1], c = 'greenyellow', label = 'WM')
    ax.scatter(X1[:,0], X1[:,1], c = 'g', label = 'WM Training')
    ax.scatter(X2[:,0], X2[:,1], c = 'k', label = 'GM Training')
    ax.set_xlabel('T1w intensities')
    ax.set_ylabel('T2w intensities')
    ax.set_title('Hyperplane?: C1 and C2 training samples onto all segmented voxels')

    plt.axis([0, 750, 0, 400])
    plt.legend()
    plt.show()

    # Projection of the training data onto the hyperplane
    fig, ax = plt.subplots(1,1, figsize = (10,5))
    ax.scatter(X1[:,0], X1[:,1], c = 'g', label = 'WM Training')
    ax.scatter(X2[:,0], X2[:,1], c = 'k', label = 'GM Training')
    W_ = W[0,1:] # The weights indicate the normal to the hyperplane, for the projection we need the perpendicular
    W_ = (W_/np.linalg.norm(W_))[::-1]
    W_[0] = -W_[0]
    for point in X1:
        proj = np.dot(point,W_)/np.dot(W_,W_) * W_
        ax.scatter(proj[0],proj[1],color='g')

    for point in X2:
        proj = np.dot(point,W_)/np.dot(W_,W_) * W_
        ax.scatter(proj[0],proj[1],color='k')

    plt.legend()
    plt.show()

    # W_ = W[1,1:] # The weights indicate the normal to the hyperplane, for the projection we need the perpendicular
    # W_ = (W_/np.linalg.norm(W_))[::-1]
    # W_[0] = -W_[0]
    # for point in X1:
    #   proj = np.dot(point,W_)/np.dot(W_,W_) * W_
    #   ax.scatter(proj[0],proj[1],color='r')

    # for point in X2:
    #   proj = np.dot(point,W_)/np.dot(W_,W_) * W_
    #   ax.scatter(proj[0],proj[1],color='b')

def exercise11():
    tmp = np.zeros(mask_WM.shape)
    red_WM = np.stack((mask_WM, tmp, tmp), axis = -1)
    green_GM = np.stack((tmp, mask_GM, tmp), axis = -1)

    fig, axs = plt.subplots(2, 3, figsize = (15, 10))
    axs[0,0].imshow(ImgT1, cmap = 'gray')
    axs[0,0].set_title('T1w')
    axs[0,1].imshow(overlay_segmentation(ImgT1, mask_WM))
    axs[0,1].set_title('WM')
    axs[0,2].imshow(overlay_segmentation(ImgT1, mask_GM))
    axs[0,2].set_title('GM')

    axs[1,0].imshow(ImgT2, cmap = 'gray')
    axs[1,0].set_title('T2w')
    axs[1,1].imshow(overlay_segmentation(ImgT2, mask_WM))
    axs[1,1].set_title('WM')
    axs[1,2].imshow(overlay_segmentation(ImgT2, mask_GM))
    axs[1,2].set_title('GM')

    plt.show()


mask = exercise1()
exercise2()
exercise3()
X, T, X1, X2 = exercise4()
X1.shape
exercise5(X1, X2)
W = exercise6(X, T)
Xall, Y = exercise7(mask, W)
PosteriorProb = exercise8(Y)
mask_WM, mask_GM = exercise9(PosteriorProb, mask)
exercie10(PosteriorProb, Xall, X1, X2)
exercise11()




